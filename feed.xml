<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Lonny's Blogs</title>
        <description>Doing is better than saying.</description>
        <link>moonccl.github.io</link>
        <atom:link href="moonccl.github.io/feed.xml" rel="self" type="application/rss+xml" />
        
            <item>
                <title>《卓有成效的管理者》读书笔记</title>
                <description>&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1322025/&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;book-img&quot; src=&quot;http://moonccl.github.io/img/loading.gif&quot; data-src=&quot;https://img3.doubanio.com/lpic/s1441092.jpg&quot; /&gt;&lt;/a&gt;某天闹书荒，就从老公那儿随便拿了本他刚买的书读。本来也就本着随便翻翻的态度，书名《卓有成效的管理者》让我觉得离我挺远的。我读书一般会翻翻前言和序，如果没意思就跳过去读正文。这本书的推荐序就有点夸张了，跳过去以后，五分之一的书就算读完了……这不禁让我怀疑这是本坑钱的成功学书籍。&lt;/p&gt;

&lt;p&gt;但是里面的很多观点其实也挺让现阶段的我有所启发的，而且这本书挺适合速读的——跳过例子、只看段首论点、感兴趣的地方再细读。大概花了一两个小时读完，居然觉得这是一本值得整理论点的书（对于我还挺难得的），所以就打算写下这篇读书笔记。&lt;/p&gt;

&lt;p&gt;从书名看，这本书讲的是如何成为高效的管理者，但对于从事知识型职业的人来说，绝大部分观点也同样适用于自我管理。很多观点可能并不能算是新奇，但是系统性地读下来，仍有很多值得细思的地方。因此，这篇读书笔记是对本书核心观点的整理和摘录。&lt;/p&gt;

&lt;h2 id=&quot;核心论点&quot;&gt;核心论点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;管理者的工作必须卓有成效；&lt;/li&gt;
  &lt;li&gt;卓有成效是可以学会的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;谁是管理者&quot;&gt;谁是管理者&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;责任&lt;/strong&gt;：能够凭借职位和知识，对组织有贡献的责任；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;职权&lt;/strong&gt;：能实质性地影响组织的营业能力及达成的成果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;管理者的困境&quot;&gt;管理者的困境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;时间只属于别人，不属于自己；&lt;/li&gt;
  &lt;li&gt;被迫忙于“日常工作”；&lt;/li&gt;
  &lt;li&gt;同级或上司影响效率；&lt;/li&gt;
  &lt;li&gt;除非努力保持与外界的联系，否则将日益局限于组织内部。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个组织决不能像生物一样，以自身的生存为目的，如果能延续后代就算成功了。组织是社会的一种器官，只有能为外部环境做出自己的贡献，才能算有所成就。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何掌握自己的时间&quot;&gt;如何掌握自己的时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;记录时间；&lt;/li&gt;
  &lt;li&gt;管理时间；&lt;/li&gt;
  &lt;li&gt;统一安排时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;时间也是一种特殊的资源。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何诊断自己的时间&quot;&gt;如何诊断自己的时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;找出什么事根本不必做（将时间记录拿出来，逐项自问“这件事如果不做会有什么后果”）；&lt;/li&gt;
  &lt;li&gt;哪些事可以由别人代劳；&lt;/li&gt;
  &lt;li&gt;管理者在浪费别人的时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何消除浪费时间的活动&quot;&gt;如何消除浪费时间的活动&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;找出由于缺乏制度或远见而产生时间浪费的因素；&lt;/li&gt;
  &lt;li&gt;人员过多；&lt;/li&gt;
  &lt;li&gt;组织不健全（会议太多）；&lt;/li&gt;
  &lt;li&gt;信息功能不健全。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;有效的人际关系&quot;&gt;有效的人际关系&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;互相沟通；&lt;/li&gt;
  &lt;li&gt;团队合作；&lt;/li&gt;
  &lt;li&gt;自我发展；&lt;/li&gt;
  &lt;li&gt;培养他人。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何发挥人的长处&quot;&gt;如何发挥人的长处&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;有效的管理者知道他们之所以用人，是用人来做事，而不是用人来投主管之所好。他们知道，一个红得发紫的女明星能有票房，让她发发脾气又有什么关系呢。&lt;/p&gt;

  &lt;p&gt;有效的管理者从来不问：“他能跟我合得来吗？”他们问的是：“他贡献了什么？”&lt;/p&gt;

  &lt;p&gt;能建立起第一流经营体制的管理者，通常不会与周围的同事及下属保持过分亲密的关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;如何管理上司&quot;&gt;如何管理上司&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;运用上司的长处，也是下属工作卓有成效的关键。&lt;/p&gt;

  &lt;p&gt;有效的管理者制度他的上司是人，所以也知道他的上司一定自有一套有效的方式，他会设法探寻出上司的这套方式。（比如喜欢浓缩的报告还是详细的报告。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;要事优先&quot;&gt;要事优先&lt;/h2&gt;

&lt;p&gt;重要的不是决定什么事该做，而是决定什么事该不做。&lt;/p&gt;

&lt;h2 id=&quot;如何做决策&quot;&gt;如何做决策&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;一位有效的决策者碰到问题，总是先假定该问题为“经常性质”。他总是先假定该问题是一种表面现象，另有根本性的问题存在。他要找出真正的问题，不会满足于解决表面现象这类问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;有效的决策&quot;&gt;有效的决策&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;决策不是从搜集事实开始，而是先有自己的见解。这样做是正确的。因为凡在某一领域具有经验者，都应该有他的见解。&lt;/p&gt;

  &lt;p&gt;一定要先有若干种不同的衡量方案（如收益、投入），再选最适当的一种。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
                <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
                <link>moonccl.github.io/2017/09/20/reviewing-the-effective-executive/</link>
                <guid isPermaLink="true">moonccl.github.io/2017/09/20/reviewing-the-effective-executive/</guid>
            </item>
        
            <item>
                <title>卡通渲染（上）</title>
                <description>&lt;p&gt;&lt;a href=&quot;moonccl.github.io/2017/02/24/what-is-a-shader/&quot;&gt;上一篇博客&lt;/a&gt;介绍了什么是着色器，以及着色器能实现的一些效果。在这一篇博客中，我将通过&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93&quot;&gt;卡通渲染&lt;/a&gt;的例子，介绍如何写一个非常简单的着色器。在本文结束的时候，我们将能够实现一种将画面中的颜色分为若干颜色层次的卡通渲染效果。&lt;/p&gt;

&lt;p&gt;这一系列教程的源代码可以在 GitHub 的 &lt;a href=&quot;https://github.com/Ovilia/cezanne&quot; onclick=&quot;_gaq.push(['_trackEvent', 'ToGitHub', window.location.pathname, 'cezanne1']);&quot;&gt;Ovilia/cezanne&lt;/a&gt; 项目访问到，欢迎关注项目。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;http://moonccl.github.io/img/loading.gif&quot; data-src=&quot;moonccl.github.io/img/post/2017-03-05-cartoon-shading-1-result.png&quot; alt=&quot;&quot; /&gt;
    &lt;figcaption&gt;本文实现的卡通渲染效果&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;为了使这一系列的教程足够简单，我将不会从正统的“渲染流水线”开始介绍，那样读者会被绕得晕头转向，而是只介绍你需要了解的最小知识。如果看完这些教程，自己感兴趣的话，可以去搜索相关资料自行学习。&lt;/p&gt;

&lt;p&gt;本系列的目标是，对图形学没有很多了解、数学功底不是很好的读者也能看懂，理解着色器代码的基本算法原理。对于有更高要求的读者，也可以根据&lt;a href=&quot;https://github.com/Ovilia/cezanne&quot; onclick=&quot;_gaq.push(['_trackEvent', 'ToGitHub', window.location.pathname, 'cezanne-source']);&quot;&gt;源码&lt;/a&gt;方便地学习更多技术细节。&lt;/p&gt;

&lt;h1 id=&quot;着色器的分类&quot;&gt;着色器的分类&lt;/h1&gt;

&lt;p&gt;最常用到的两种着色器分别为&lt;em&gt;顶点着色器&lt;/em&gt;（&lt;em&gt;Vertex Shader&lt;/em&gt;）和&lt;em&gt;片元着色器&lt;/em&gt;（&lt;em&gt;Fragment Shader&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;首先需要明确的概念是，&lt;strong&gt;片元着色器是在顶点着色器之后被调用的&lt;/strong&gt;，因而也可以从顶点着色器往片元着色器传递参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其他类型的着色器参阅 &lt;a href=&quot;https://www.khronos.org/opengl/wiki/Shader&quot;&gt;Shader - OpenGL Wiki - Khronos Group&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;顶点着色器&quot;&gt;顶点着色器&lt;/h2&gt;

&lt;p&gt;什么是顶点呢？&lt;/p&gt;

&lt;p&gt;比如你用 OpenGL 画一个三角形，那就是创建了三个顶点。&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;顶点着色器就是每个顶点调用一次的程序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在顶点着色器中，可以访问到顶点的三维位置、颜色、法向量等信息。可以通过修改这些值，或者将其传递到片元着色器中，实现特定的渲染效果。&lt;/p&gt;

&lt;h2 id=&quot;片元着色器&quot;&gt;片元着色器&lt;/h2&gt;

&lt;p&gt;“片元”的概念大家可能相对陌生一些。但是一个相似的概念是“像素”，这你一定听说过。&lt;/p&gt;

&lt;p&gt;场景渲染到显示器的过程中，有一个步骤叫&lt;em&gt;光栅化&lt;/em&gt;（&lt;em&gt;Rasterization&lt;/em&gt;）。由于我们现在的显示器绝大多数是基于像素的（就是由一个个非常小的红绿蓝 LED 组成的显示单元），所以“连续”的三维场景，要显示到“离散”的显示器上，需要经过的变化操作就叫光栅化。&lt;/p&gt;

&lt;p&gt;光栅化后得到的就得到了一个个“片元”。片元和像素已经非常接近了，但两者仍是有区别的。用一种通俗的说法来解释的话，就是比如三维空间内有两个从摄像机角度看过去一前一后的三角形，它们重叠部分的显示区域，每个像素对应两个片元；不重叠的部分，像素和片元一一对应。当然，这个例子是我简化过的，真实的对应关系可能更复杂一些。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;更专业的说法是，片元在成为像素之前，还会做多种测试（比如深度测试、透明度测试、模板测试）以决定其最终是否会被显示为像素。所以，严格来说，“片元”和“像素”并不是一一对应的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是，这里我们并不需要了解片元的概念太深刻，只要知道它是非常接近像素，但是又不等同于像素的就可以了。&lt;/p&gt;

&lt;p&gt;同样，&lt;strong&gt;片元着色器就是每个片元调用一次的程序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在片元着色器中，可以访问到片元在二维屏幕上的坐标、深度信息、颜色等信息。通过改变这些值，可以实现特定的渲染效果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，同样是颜色信息，在顶点着色器中，得到的是顶点的颜色，而在片元着色器中，得到的是片元的颜色——也就是说，如果三角形的三个顶点颜色是不同的，片元的颜色就是根据这三个顶点的颜色进行插值后的，也可以通俗地理解为，是渐变的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;卡通渲染&quot;&gt;卡通渲染&lt;/h1&gt;

&lt;p&gt;我们在本文实现的根据亮度分为若干颜色梯度的效果，是卡通渲染（Toon Shading）的一种形式，称为 Cel Shading。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Cel” is the first syllable of “celluloid”, a plastic made of cellulose nitrate. Before digital ink-and-paint software, the pencil drawings used in hand-drawn animation were transferred onto these sheets of clear plastic by skilled artists using ink and paint, or by using a special Xerox process (“Xerography”) and paint. Later cels were made of cellulose acetate instead of cellulose nitrate, but still called “cels.” Collectors spend a lot of money to buy these pieces of animation history.&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;From &lt;a href=&quot;http://www.celshader.com/FAQ.html&quot;&gt;Celshader.com FAQ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如何在 Three.js 中使用着色器的方法，请参考&lt;a href=&quot;https://read.douban.com/ebook/7412854/&quot;&gt;《Three.js 入门指南》&lt;/a&gt;，本文不再赘述。不了解的读者，也不影响阅读后面的着色器算法部分。&lt;/p&gt;

&lt;h2 id=&quot;卡通渲染算法的原理&quot;&gt;卡通渲染算法的原理&lt;/h2&gt;

&lt;p&gt;Cel Shading 算法可以有若干种变形，我们这里介绍一种简单的算法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;指定一个颜色作为苹果的基础颜色；&lt;/li&gt;
  &lt;li&gt;通过光照计算得出每个片元对应的亮度；&lt;/li&gt;
  &lt;li&gt;将亮度由连续的映射到离散的若干个亮度值；&lt;/li&gt;
  &lt;li&gt;将亮度值和基础颜色结合得到片元颜色。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，比较麻烦的是第 2 步的“光照计算”。那么，光照是怎么被计算出来的呢？这就要扯一扯 OpenGL 的矩阵变换了。&lt;/p&gt;

&lt;h2 id=&quot;矩阵变换&quot;&gt;矩阵变换&lt;/h2&gt;

&lt;p&gt;这里，我们就要祭出我画的这个神图了——&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;http://moonccl.github.io/img/loading.gif&quot; data-src=&quot;moonccl.github.io/img/post/2015-08-28-opengl-matrix-transformations-02.png&quot; alt=&quot;&quot; /&gt;
    &lt;figcaption&gt;OpenGL 中的矩阵变换示意图&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;想详细了解的读者，请参见我之前写的博文&lt;a href=&quot;moonccl.github.io/2015/08/28/opengl-matrix-transformations/&quot;&gt;《这次，彻底搞懂 OpenGL 矩阵转换》&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文将不对矩阵变换的细节详细展开，你只需要知道这个公式：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;single-img&quot; src=&quot;http://moonccl.github.io/img/loading.gif&quot; data-src=&quot;moonccl.github.io/img/post/2017-03-05-cartoon-shading-1-matrix.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，中间的三项有个非常霸气的名字：&lt;strong&gt;MVP 矩阵&lt;/strong&gt;！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么不是 PVM 啊？&lt;/p&gt;

  &lt;p&gt;因为从逻辑上来说，是先把模型点坐标向量乘以模型矩阵，然后乘以视图矩阵，然后乘以投影矩阵，然后乘以视口矩阵的。所以先后顺序的确是 MVP。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们知道矩阵乘法是一个很耗时的操作，而由于模型矩阵和视图矩阵更可能是不变的，因而根据矩阵结合律，将它们先相乘得到模型视图矩阵（modal-view matrix），再与点坐标相乘。这样，以后几帧的计算，就可以不用分别乘以模型矩阵和视图矩阵，而是只乘以模型视图矩阵，达到减少矩阵乘法的次数的效果。&lt;/p&gt;

&lt;p&gt;这一点稍作了解即可，如果看不懂，你只需要了解——&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个物体的三维坐标向量，乘以模型视图矩阵后，能够得到它在试图坐标系中的位置，也就是它相对于摄像机的坐标位置。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何进行光照计算&quot;&gt;如何进行光照计算&lt;/h2&gt;

&lt;p&gt;在明白了这点之后，我们就能够理解如何进行光照计算了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将光源位置（这是通过参数传入的）乘以模型视图矩阵（这是着色器提供给我们的），就能得到光源相对于摄像机的位置；&lt;/li&gt;
  &lt;li&gt;将这一位置归一化（就是计算单位向量），得到光源相对于摄像机的角度；&lt;/li&gt;
  &lt;li&gt;将其点乘单位法向量，得到亮度值（回想一下，两个向量点乘的意思是，获得一个向量在另一个向量上的投影，所以，这里得到的是光源在法向量方向的投影长度，它决定了一个点有多亮）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个亮度值就可以直接使用在第 3 步中。&lt;/p&gt;

&lt;h1 id=&quot;着色器基础知识&quot;&gt;着色器基础知识&lt;/h1&gt;

&lt;p&gt;让我们通过卡通渲染的顶点着色器代码，了解着色器的基础知识。&lt;/p&gt;

&lt;h2 id=&quot;顶点着色器-1&quot;&gt;顶点着色器&lt;/h2&gt;

&lt;p&gt;顶点着色器的完整代码如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;uniform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uniform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;light&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// pass to fs&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vNormal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normalMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewLight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;light&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vLight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;gl_Position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;projectionMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelViewMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码至少我们能看懂入口是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数开始的，和 C 程序一样，可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数上方声明一些变量。&lt;/p&gt;

&lt;p&gt;在这个例子中，有两类变量，一类是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniform&lt;/code&gt; 开头的，另一类是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;varing&lt;/code&gt; 开头的。着色器变量的存储限定符（Storage Qualifiers）有这么几种：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;(无)&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;（默认值），在当前着色器程序或函数参数中的可读写变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;const&lt;/td&gt;
      &lt;td&gt;编译时能确定的常量，或只读函数参数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;attribute&lt;/td&gt;
      &lt;td&gt;从 OpenGL 代码传入顶点着色器的变量，每个顶点分别对应一个值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;uniform&lt;/td&gt;
      &lt;td&gt;从 OpenGL 代码传入顶点着色器的变量，所有顶点对应同样的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;varing&lt;/td&gt;
      &lt;td&gt;从顶点着色器传入片元着色器的变量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;参见 &lt;a href=&quot;https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf&quot;&gt;WebGL 1.0 API Quick Reference Card&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;uniform-和-attribute&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uniform&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;attribute&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uniform&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;attribute&lt;/code&gt; 是在 OpenGL 代码中传入着色器的，在 Three.js 中，通常是这么写的：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;material&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ShaderMaterial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;vertexShader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 可以通过 AJAX 加载 *.vs 代码，内容传给这个变量&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;fragmentShader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;uniforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 苹果的基础色&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'v3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 指定变量类型为三维向量&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;THREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'#60371b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;light&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 光源位置&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'v3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keyLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mesh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;material&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;material&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们把苹果的基础颜色定位整体是同一个颜色，所以这里用 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniform&lt;/code&gt; 告诉顶点着色器，每个顶点都获得同样的颜色值。相对地，如果我们要为每个顶点指定不同的颜色，那么就需要用 &lt;code class=&quot;highlighter-rouge&quot;&gt;attribtue&lt;/code&gt; 传入数组，告诉顶点着色器，每个顶点对应使用什么颜色。&lt;/p&gt;

&lt;p&gt;在卡通渲染的着色器中，我们传入了两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniform&lt;/code&gt; 值，分别是苹果的基础颜色和光源位置。&lt;/p&gt;

&lt;h3 id=&quot;varing&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;varing&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;varing&lt;/code&gt; 类型的变量是从顶点着色器往片元着色器传递的，因为 OpenGL 不能直接给片元着色器传信息。需要传递时，在顶点着色器 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数之前定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;varing&lt;/code&gt; 开头的变量即可。&lt;/p&gt;

&lt;p&gt;在这里，我们传递了三个变量到面片着色器，分别是：&lt;code class=&quot;highlighter-rouge&quot;&gt;vColor&lt;/code&gt; 表示苹果基础色、&lt;code class=&quot;highlighter-rouge&quot;&gt;vNormal&lt;/code&gt; 表示顶点法向量、&lt;code class=&quot;highlighter-rouge&quot;&gt;vLight&lt;/code&gt; 表示光源相对于摄像机的坐标。&lt;/p&gt;

&lt;h3 id=&quot;变量类型&quot;&gt;变量类型&lt;/h3&gt;

&lt;p&gt;前面说的 &lt;code class=&quot;highlighter-rouge&quot;&gt;uniform&lt;/code&gt; 之类的是“限定词”，修饰了变量的来源和特点，而变量类型则是在限定词之后出现的。&lt;/p&gt;

&lt;p&gt;C 语言中支持的 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 等类型都是支持的。除此之外，这里我们用到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;vec3&lt;/code&gt; 类型声明的是一个三维向量，对应地，还有 &lt;code class=&quot;highlighter-rouge&quot;&gt;vec2&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;vec4&lt;/code&gt; 表示二维、四维数组；&lt;code class=&quot;highlighter-rouge&quot;&gt;mat2&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;mat3&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;mat4&lt;/code&gt; 表示二阶、三阶、四阶矩阵。还有比较特别的 &lt;code class=&quot;highlighter-rouge&quot;&gt;sampler2D&lt;/code&gt; 传纹理、&lt;code class=&quot;highlighter-rouge&quot;&gt;samplerCuber&lt;/code&gt; 传立方体纹理，暂时我们不会用到。&lt;/p&gt;

&lt;p&gt;需要注意的是，&lt;strong&gt;GLSL 是类 C 语言的，千万不要用 JavaScript 的思路去思考&lt;/strong&gt;。一个典型的错误是，GLSL 是没有隐式类型转换的，因此如果一个变量是 &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; 类型的，写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; 会在编译着色器时报错，一定要写为 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0&lt;/code&gt; 才行。&lt;/p&gt;

&lt;h3 id=&quot;辅助函数&quot;&gt;辅助函数&lt;/h3&gt;

&lt;p&gt;虽然类 C 语言的风格，让我们这群写 JavaScript 自由惯了的程序员很抓狂，但比较好的特性是，它提供了一些很方便的辅助函数。&lt;/p&gt;

&lt;p&gt;向量类型的变量互相转换，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;viewLight&lt;/code&gt; 是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;vec4&lt;/code&gt; 类型，如果将它前三个维度给一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;vec3&lt;/code&gt; 类型，就可以写成：&lt;code class=&quot;highlighter-rouge&quot;&gt;viewLight.xyz&lt;/code&gt;。更神奇的是，打乱顺序也是可以的，也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;viewLight.zx&lt;/code&gt; 能将第三个维度和第一个维度赋值给一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;vec2&lt;/code&gt; 类型。&lt;/p&gt;

&lt;p&gt;另外，提供了很多辅助函数，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;normalize&lt;/code&gt; 可以将向量归一化，&lt;code class=&quot;highlighter-rouge&quot;&gt;dot&lt;/code&gt; 可以获得两个向量的点积。&lt;/p&gt;

&lt;h1 id=&quot;算法理解&quot;&gt;算法理解&lt;/h1&gt;

&lt;h2 id=&quot;顶点着色器-2&quot;&gt;顶点着色器&lt;/h2&gt;

&lt;p&gt;现在，我们应该能够读懂着色器代码了。再来看下 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数中的代码：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// pass to fs&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;vColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;vNormal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;normalMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;viewLight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;viewMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;light&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;vLight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;viewLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;gl_Position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;projectionMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;modelViewMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数会被每个顶点执行一次，并且是在 GPU 中并行执行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，我们将从 Three.js 中获得的颜色赋值给 &lt;code class=&quot;highlighter-rouge&quot;&gt;vColor&lt;/code&gt; 变量，让它传递给片元着色器。&lt;/p&gt;

&lt;p&gt;然后，使用法向矩阵乘以法向量，并将其归一化后，传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;vNormal&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;等等……这里怎么又出现一个新矩阵了？我头都晕啦！&lt;/p&gt;

  &lt;p&gt;好吧，你其实并不需要知道&lt;a href=&quot;http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/&quot;&gt;背后的原理&lt;/a&gt;，只需要知道，这是为了将物体坐标系下的法向量方向，转变成视图坐标系下的法向量方向。而之所以不能和光源位置 &lt;code class=&quot;highlighter-rouge&quot;&gt;light&lt;/code&gt; 一样乘以 &lt;code class=&quot;highlighter-rouge&quot;&gt;modelViewMatrix&lt;/code&gt;，本质上的区别是，它们虽然都是三维向量，但法向量表示的是一个方向，而光源位置表示的是一个坐标。如果用法向量乘以 &lt;code class=&quot;highlighter-rouge&quot;&gt;modelViewMatrix&lt;/code&gt; 的话，得到的结果就可能不再垂直于面片了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接着，使用光源位置乘以视图矩阵，得到光源在视图坐标系下的位置，传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;vLight&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后，将 MVP 矩阵乘以顶点坐标 &lt;code class=&quot;highlighter-rouge&quot;&gt;position&lt;/code&gt;（都由着色器提供）的结果赋值给 &lt;code class=&quot;highlighter-rouge&quot;&gt;gl_Position&lt;/code&gt;。这句是最常用的顶点着色器中顶点位置的写法，如果你不需要改变顶点的位置，则都是这样写的。&lt;/p&gt;

&lt;p&gt;现在，我们已经读懂顶点着色器啦！&lt;/p&gt;

&lt;h2 id=&quot;片元着色器-1&quot;&gt;片元着色器&lt;/h2&gt;

&lt;p&gt;有了顶点着色器代码理解的基础，片元着色器就很容易读懂啦！&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vLight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vNormal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;gl_FragColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diffuse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数会被每个片元执行一次，并且是在 GPU 中并行执行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数的上方，我们还是定义了一些外部来的变量。在这个例子中，它们都是从顶点着色器传递过来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;varing&lt;/code&gt; 变量。&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数中，我们根据把归一化后的光源方向，和法向量进行点乘，计算每个片元的亮度值。&lt;/p&gt;

&lt;p&gt;然后，根据亮度值，分别阶梯式地映射到新的亮度值，得到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;diffuse&lt;/code&gt; 是一个 0 到 1 之间的值。&lt;/p&gt;

&lt;p&gt;最后，让苹果的基础颜色的 RGB 通道分别乘以阶梯式的亮度值，得到每个片元的颜色，并复制给 &lt;code class=&quot;highlighter-rouge&quot;&gt;gl_FragColor&lt;/code&gt; 作为片元的颜色输出。&lt;/p&gt;

&lt;p&gt;渲染结果如下：&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;http://moonccl.github.io/img/loading.gif&quot; data-src=&quot;moonccl.github.io/img/post/2017-03-05-cartoon-shading-1-result.png&quot; alt=&quot;&quot; /&gt;
    &lt;figcaption&gt;卡通渲染效果&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;

&lt;p&gt;哇晒！我们全学会了！:heart_eyes:&lt;/p&gt;

&lt;p&gt;数学不好、没有图形学基础，但也看懂了的同学请举个手！:muscle:&lt;/p&gt;

&lt;div class=&quot;split&quot;&gt;&lt;/div&gt;

&lt;p&gt;之后的教程也会像这篇一样，在介绍有限的数学、图形学相关知识的条件下，尽可能让大家明白着色器的算法原理。并且让感兴趣的读者，也能够有进一步研究实现方式的途径。希望能和大家一起学习！&lt;/p&gt;

&lt;p&gt;欢迎大家在 GitHub 上关注 &lt;a href=&quot;https://github.com/Ovilia/cezanne&quot; onclick=&quot;_gaq.push(['_trackEvent', 'ToGitHub', window.location.pathname, 'cezanne2']);&quot;&gt;Ovilia/cezanne&lt;/a&gt;，查看源码或关注更新~ 也非常欢迎交流讨论！:wink:&lt;/p&gt;

&lt;p&gt;下一篇，我们将介绍卡通渲染算法中，添加描边的效果，敬请期待！&lt;/p&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://read.douban.com/ebook/7412854/&quot;&gt;《Three.js入门指南》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5273949/&quot;&gt;《OpenGL超级宝典》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3175883/&quot;&gt;《OpenGL ES 2.0 Programming Guide》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf&quot;&gt;WebGL 1.0 API Quick Reference Card&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/&quot;&gt;The Normal Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <pubDate>Sun, 05 Mar 2017 00:00:00 +0800</pubDate>
                <link>moonccl.github.io/2017/03/05/cartoon-shading-1/</link>
                <guid isPermaLink="true">moonccl.github.io/2017/03/05/cartoon-shading-1/</guid>
            </item>
        
    </channel>
</rss>
